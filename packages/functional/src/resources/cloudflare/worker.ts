import Cloudflare from "cloudflare";
import assert from "node:assert";
import { watch, type FSWatcher } from "node:fs";
import path from "node:path";
import { $app } from "../../context";
import type { StandardSchemaV1 } from "../../lib/standard-schema";
import { Resource, type IResource } from "../base";
import { cfFetch, requireCloudflareAccountId } from "./api";
import type { IKVNamespace, KVNamespace } from "./kv-namespace";
import { Log, LogLevel, type MiniflareOptions } from "miniflare";
import { createHash } from "node:crypto";

type WorkerEnvironment = Record<string, any>;

export interface IWorker<Environment extends WorkerEnvironment>
  extends IResource {
  kind: "worker";
  options: {
    entry: string;
    format?: "esm" | "cjs";
    environment?: StandardSchemaV1<Environment>;
    bindings?: (KVNamespace | IKVNamespace["binding"])[];
  };
}

export class Worker<
  Environment extends WorkerEnvironment = WorkerEnvironment
> extends Resource<IWorker<Environment>> {
  readonly kind = "worker";

  private app = {
    cwd: $app.cwd,
    out: $app.out,
  };

  private scriptEntry = path.join(this.app.cwd, this.options.entry);
  private scriptOutDir = path.join(this.app.out, this.id);

  private async getEnvironment() {
    if (!this.options.environment && !this.options.bindings) {
      return {
        environment: {},
        kvNamespaces: [],
      };
    }
    let environment: Record<string, any> = {};
    if (this.options.environment) {
      const env = await this.options.environment["~standard"].validate(
        process.env
      );
      if (env.issues) {
        throw new Error(
          `Invalid environment variables: ${env.issues
            .map((issue) => issue.message)
            .join(", ")}`
        );
      }
      environment = env.value;
    }
    const kvNamespaces = this.options.bindings?.map(
      (binding): IKVNamespace["binding"] => {
        if ("binding" in binding) {
          return binding.binding();
        }
        return binding;
      }
    );
    await this.generateTypesFromEnvironment([
      ...Object.entries(environment).map(([name, value]) => ({
        name,
        type: typeof value,
      })),
      ...(kvNamespaces ?? []).map((binding) => ({
        name: binding.name,
        type: "KVNamespace",
      })),
    ]);
    return {
      environment,
      kvNamespaces,
    };
  }

  private async generateTypesFromEnvironment(
    items: { name: string; type: string }[]
  ) {
    const isValidPropName = (name: string) =>
      !!name.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/);
    const file = [
      "// Generated by functional.dev",
      "//",
      "// biome-ignore lint/style: auto-generated file",
      "// eslint-disable",
      "// prettier-ignore",
      "",
      '/// <reference types="@cloudflare/workers-types" />',
      "",
      "interface Env {",
      ...items.map(
        ({ name, type }) =>
          `  ${isValidPropName(name) ? name : `"${name}"`}: ${type};`
      ),
      "}",
      "",
    ].join("\n");
    await Bun.write(path.join(this.app.cwd, "worker-env.d.ts"), file);
  }

  async dev() {
    const watchers = new Map<string, FSWatcher>();
    let updatedAt = Date.now();

    const buildMiniflareOptions = async (scriptPath: string) => {
      const { environment, kvNamespaces } = await this.getEnvironment();
      return {
        name: this.name,
        scriptPath,
        modules: this.scriptFormat === "esm",
        bindings: environment,
        kvNamespaces: Object.fromEntries(
          kvNamespaces?.map((binding) => [binding.name, binding.id]) ?? []
        ),
        log: new Log(LogLevel.VERBOSE),
      } satisfies MiniflareOptions;
    };

    const buildDev = async () => {
      const devPlugin: Bun.BunPlugin = {
        name: "dev",
        setup: (builder) => {
          builder.onLoad({ filter: /\.(ts|js)$/ }, (args) => {
            console.log("onLoad", args);
            if (!watchers.has(args.path)) {
              // TODO: A better approach would be for the CLI to watch everything
              // and call a "reload" function here â€” the problem is we need
              // a way to know which file changes are relevant to this worker.
              watchers.set(args.path, watch(args.path, reload));
            }
          });
        },
      };
      return await this.buildScript([devPlugin]);
    };

    const reload = async () => {
      const now = Date.now();
      updatedAt = now;
      console.time("rebuild");
      const script = await buildDev();
      console.timeEnd("rebuild");
      if (updatedAt > now) {
        console.log("script changed during rebuild");
        return;
      }
      console.time("reload");
      // TODO: Figure out why this sometimes fails.
      // We can try recreating the Miniflare instance, but we should check the performance impact.
      await miniflare.setOptions(await buildMiniflareOptions(script.path));
      console.timeEnd("reload");
    };

    console.time("setup");
    const [{ Miniflare }, script] = await Promise.all([
      import("miniflare"),
      buildDev(),
    ]);
    console.timeEnd("setup");

    const miniflare = new Miniflare(await buildMiniflareOptions(script.path));

    return {
      fetch(request: Request) {
        return miniflare.dispatchFetch(
          request as any
        ) as unknown as Promise<Response>;
      },
      reload,
      async stop() {
        for (const [path, watcher] of watchers.entries()) {
          console.log("closing watcher", path);
          watcher.close();
        }
        await miniflare.dispose();
      },
    };
  }

  async create() {
    return await this.putScript();
  }

  async update() {
    return await this.putScript();
  }

  async delete() {
    await api.deleteScript(this.name);
  }

  private async putScript() {
    const buildOutput = await this.buildScript();
    const metadata: Cloudflare.Workers.Scripts.ScriptUpdateParams.Metadata = {
      compatibility_date: "2025-04-10",
      compatibility_flags: ["nodejs_compat_v2"],
    };
    const script = await (async () => {
      switch (this.scriptFormat) {
        case "esm":
          metadata.main_module = "worker.js";
          return {
            name: "worker.js",
            type: "application/javascript+module",
            content: await buildOutput.text(),
          };
        case "cjs":
          metadata.body_part = "script";
          return {
            name: "script",
            type: "application/javascript",
            content: await buildOutput.text(),
          };
      }
    })();
    return await api.putScript({
      name: this.name,
      script,
      metadata,
    });
  }

  private async buildScript(plugins: Bun.BunPlugin[] = []) {
    const result = await Bun.build({
      entrypoints: [this.scriptEntry],
      target: "node",
      format: this.scriptFormat,
      outdir: this.scriptOutDir,
      sourcemap: "inline",
      plugins,
    });
    const output = result.outputs[0];
    assert(output?.kind === "entry-point", "Expected entry point");
    assert(result.outputs.length === 1, "Expected exactly one output");
    return output;
  }

  private get scriptFormat() {
    return this.options.format === "cjs" ? "cjs" : "esm";
  }
}

const api = {
  putScript: async (input: {
    name: string;
    script: {
      name: string;
      type: string;
      content: string;
    };
    metadata: Cloudflare.Workers.Scripts.ScriptUpdateParams.Metadata;
  }) => {
    const accountId = await requireCloudflareAccountId();
    const formData = new FormData();

    formData.append(
      "metadata",
      new Blob([JSON.stringify(input.metadata)], {
        type: "application/json",
      })
    );
    formData.append(
      input.script.name,
      new Blob([input.script.content], {
        type: input.script.type,
      }),
      input.script.name
    );

    return await cfFetch(
      `/accounts/${accountId}/workers/scripts/${input.name}`,
      {
        method: "PUT",
        body: formData,
      }
    );
  },
  deleteScript: async (name: string) => {
    const accountId = await requireCloudflareAccountId();
    return await cfFetch(`/accounts/${accountId}/workers/scripts/${name}`, {
      method: "DELETE",
    });
  },
  uploadAssets: async (
    assets: {
      name: string;
      content: string;
      type: string;
    }[]
  ) => {
    const accountId = await requireCloudflareAccountId();

    const manifest: Record<string, { hash: string; size: number }> = {};
    const files = new Map<string, Blob>();
    for (const asset of assets) {
      const hash = createHash("sha256")
        .update(asset.content)
        .digest("hex")
        .slice(0, 32);
      manifest[asset.name] = {
        hash,
        size: asset.content.length,
      };
      files.set(
        hash,
        new Blob([Buffer.from(asset.content).toString("base64")], {
          type: asset.type,
        })
      );
    }

    const { jwt, buckets } = await cfFetch<{
      jwt: string;
      buckets?: string[][];
    }>(`/accounts/${accountId}/workers/assets-upload-session`, {
      method: "POST",
      body: JSON.stringify({ manifest }),
    });

    if (!buckets || buckets.length === 0) {
      return {
        jwt,
      };
    }

    let completionToken = jwt;

    for (const bucket of buckets) {
      const formData = new FormData();
      for (const fileHash of bucket) {
        const file = files.get(fileHash);
        if (!file) {
          throw new Error(`File ${fileHash} not found`);
        }
        formData.append("files", file);
      }
      const uploadResponse = await cfFetch<{
        jwt?: string;
      }>(`/accounts/${accountId}/workers/assets/upload?base64=true`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${completionToken}`,
        },
        body: formData,
      });
      completionToken = uploadResponse.jwt ?? completionToken;
    }

    return {
      jwt: completionToken,
    };
  },
  getWorkersDevSubdomain: async () => {
    const accountId = await requireCloudflareAccountId();
    const res = await cfFetch<{
      subdomain: string;
    }>(`/accounts/${accountId}/workers/subdomains`, {
      method: "GET",
    });
    return res.subdomain;
  },
  setWorkersDevEnabled: async (scriptName: string, enabled: boolean) => {
    const accountId = await requireCloudflareAccountId();
    await cfFetch(
      `/accounts/${accountId}/workers/scripts/${scriptName}/subdomain`,
      {
        method: "POST",
        body: JSON.stringify(
          enabled
            ? { enabled: true, previews_enabled: true }
            : { enabled: false }
        ),
      }
    );
  },
};
